<!DOCTYPE  html>
<html>
  <head>
    <meta charset="utf-8">
    
    <title>doc</title>
    <style>
      /*github.com style (c) Vasily Polovnyov <vast@whiteants.net>*/
      pre code {
        display: block; padding: 0.5em;
        color: #333;
        background: #f8f8ff
      }
      pre .comment,
      pre .template_comment,
      pre .diff .header,
      pre .javadoc {
        color: #998;
        font-style: italic
      }
      pre .keyword,
      pre .css .rule .keyword,
      pre .winutils,
      pre .javascript .title,
      pre .nginx .title,
      pre .subst,
      pre .request,
      pre .status {
        color: #333;
        font-weight: bold
      }
      pre .number,
      pre .hexcolor,
      pre .ruby .constant {
        color: #099;
      }
      pre .string,
      pre .tag .value,
      pre .phpdoc,
      pre .tex .formula {
        color: #d14
      }
      pre .title,
      pre .id {
        color: #900;
        font-weight: bold
      }
      pre .javascript .title,
      pre .lisp .title,
      pre .clojure .title,
      pre .subst {
        font-weight: normal
      }
      pre .class .title,
      pre .haskell .type,
      pre .vhdl .literal,
      pre .tex .command {
        color: #458;
        font-weight: bold
      }
      pre .tag,
      pre .tag .title,
      pre .rules .property,
      pre .django .tag .keyword {
        color: #000080;
        font-weight: normal
      }
      pre .attribute,
      pre .variable,
      pre .lisp .body {
        color: #008080
      }
      pre .regexp {
        color: #009926
      }
      pre .class {
        color: #458;
        font-weight: bold
      }
      pre .symbol,
      pre .ruby .symbol .string,
      pre .lisp .keyword,
      pre .tex .special,
      pre .prompt {
        color: #990073
      }
      pre .built_in,
      pre .lisp .title,
      pre .clojure .built_in {
        color: #0086b3
      }
      pre .preprocessor,
      pre .pi,
      pre .doctype,
      pre .shebang,
      pre .cdata {
        color: #999;
        font-weight: bold
      }
      pre .deletion {
        background: #fdd
      }
      pre .addition {
        background: #dfd
      }
      pre .diff .change {
        background: #0086b3
      }
      pre .chunk {
        color: #aaa
      }
    </style>
  </head>
  <body>  
    <h1 id="quick-coffeescript-guide-copy-from-an-old-2013-repo-">Quick CoffeeScript guide (copy from an old 2013 repo)</h1>
<h2 id="vars">Vars</h2>
<p>There&#39;s no need to worry about global scope, hoisting and similar, CS handles that moving vars to the top of the scope.</p>
<pre><code class="lang-coffeescript">name = &quot;Sergio&quot;
year = 2013</code></pre>
<h2 id="strings">Strings</h2>
<p>It omits returns</p>
<pre><code class="lang-coffeescript">text = &quot;This is a
    test&quot;
console.log text # &#39;This is a test&#39;</code></pre>
<p>If we want returns, we must use <code>&quot;&quot;&quot;</code></p>
<pre><code class="lang-coffeescript">text = &quot;&quot;&quot;
  This is a
  test&quot;&quot;&quot;
console.log text # &#39;This is a
test&#39;</code></pre>
<h2 id="comments">Comments</h2>
<pre><code class="lang-coffeescript"># This is a comment</code></pre>
<p>Same as with Strings, we can make them multiline with <code>###</code></p>
<pre><code class="lang-coffeescript">###
This is a
multiline comment
###</code></pre>
<h2 id="string-interpolation">String interpolation</h2>
<pre><code class="lang-coffeescript">name = &quot;Sergio&quot;
text = &quot;My name is #{name}&quot;</code></pre>
<h2 id="ifs">IFs</h2>
<pre><code class="lang-coffeescript">if name === &quot;Sergio&quot;
  me = true
else
  me = false

if name is &quot;Sergio&quot; then me = true else me = false
me = (if name is &quot;Sergio&quot; then true else false)
me = true if name is &quot;Sergio&quot;
me = false if name isnt &quot;Sergio&quot;
me = false unless name is &quot;Sergio&quot;</code></pre>
<h2 id="loops">Loops</h2>
<h3 id="while-until">While / Until</h3>
<pre><code class="lang-coffeescript">count = 0
while count &lt;= 10
  count++

while count &lt;= 10 then count++
unless count is 10 then count++</code></pre>
<h3 id="for">For</h3>
<pre><code class="lang-coffeescript">animals = [&quot;dog&quot;, &quot;cat&quot;, &quot;cow&quot;]
for animal in animals
  console.log animal

# modifying the increment
for animal in animals by 2
  console.log animal
  # it returns &quot;dog&quot;, &quot;cow&quot;

console.log animal for animal in animals by 2

# con condicionales
console.log animal for animal in animal when animal[0] is &quot;c&quot; #&quot;cat&quot;,&quot;cow&quot;</code></pre>
<h3 id="loop">Loop</h3>
<pre><code class="lang-coffeescript">count = 0
loop
  break if count is 10
  count++</code></pre>
<h2 id="aliases-and-operators">Aliases and operators</h2>
<p><code>=== is</code>
<code>!== isnt</code>
<code>|| or</code>
<code>&amp;&amp; and</code>
<code>! not</code>
<code>?</code> operator of existence, to make stuff like:</p>
<pre><code class="lang-coffeescript">name = names[0] ? &quot;Sergio&quot; #by default
player?.fire?() # if player exists and fire method exists, executes it</code></pre>
<p>@ this
<code>@name = &quot;Sergio&quot; # this.name = &quot;Sergio&quot;</code>
:: prototype
<code>player::life = 5</code></p>
<h2 id="functions">Functions</h2>
<pre><code class="lang-coffeescript">hello = -&gt; &quot;world&quot;
do hello
###
var hello = function() {
  return &quot;world&quot;;
}
hello()
###
hi = (a = &quot;Sergio) -&gt; &quot;hello #{a}&quot;
hi() # &quot;hello Sergio&quot;
hi &quot;Mike&quot; # &quot;hello Mike&quot;
###
var hi = function(a) {
  if (a == null) {
    a = &quot;Sergio&quot;
  }
  return &quot;hello &quot; + a;
}
###
sum = (numbers...) -&gt;
  result = 0
  numbers.forEach (number) -&gt; result = result + number
  resultB
miSuma = sum 1, 2, 3, 4, 5
alert sum 1, 2, 3, 4, 5 #alert(sum(1,2,3,4,5))</code></pre>
<h3 id="scope">Scope</h3>
<p>It&#39;s defined with the first assign of a var</p>
<h3 id="context">Context</h3>
<p>With <code>new</code> the context is the new object
With <code>call</code> and <code>apply</code> is the first argument
If it isn&#39;t any of those, the context is global</p>
<h3 id="changing-context-in-functions">Changing context in functions</h3>
<p>Declaring them with fat arrow <code>=&gt;</code> instead of normal arrow.</p>
<h2 id="objets">Objets</h2>
<p>Can be declared without curly braces or comas:</p>
<pre><code class="lang-coffeescript">inhabitants =
  eri:
    age: 27
    occupation: &quot;Doctor&quot;
  sergio:
    age: 27
    occupation: &quot;Developer&quot;</code></pre>
<p>Another oneliner example
<code>fellowship = wizard: &#39;Gandalf&#39;, hobbits: [&#39;Frodo&#39;, &#39;Pippin&#39;, &#39;Sam&#39;]</code>
Knowing if a property exists in an object:
<code>console.log wizard of fellowship</code></p>
<h2 id="arrays">Arrays</h2>
<p>Brackets are needed <code>[]</code>, commas aren&#39;t
Ex:
<code>Math.max [1,10,3,6,2]...</code> #returns 10
We can use reduce, reduceRight, map...
<code>console.log [1..10], [10..1] #[1,2,3,4,5,6,7,8,9,10] [10,9,8,7,6,5,4,3,2,1]</code>
<code>console.log [1...10] #[1,2,3,4,5,6,7,8,9] I mean, it&#39;s like [1,10)</code></p>
<h2 id="classes">Classes</h2>
<h3 id="prototype">Prototype</h3>
<pre><code class="lang-coffeescript">Hero = (@power) -&gt;
  Hero::says = -&gt; console.log &quot;My superpower is #{@power}!&quot;

#mixing prototype and static
Hero = (@power) -&gt;
  Hero.count++
  @number = Hero.count
  @says()
Hero.count = 0
Hero::says = -&gt; console.log &quot;#{@number}. My superpower is #{@power}!&quot;</code></pre>
<h3 id="classes">Classes</h3>
<pre><code class="lang-coffeescript">class Hero
  #static private
  _count = 0
  constructor: (@power) -&gt;
    _count++
    @says ()

  #Instance methods
  says: -&gt; console.log &quot;#{@number()}. My superpower is #{@power}!&quot;

  number: -&gt; _count

  #static public method
  @count: -&gt; console.log &quot;Number of instances #{_count}&quot;

superman = new Hero &quot;fly&quot;
batman = new Hero &quot;a belt with gadgets&quot;
Hero.count() # &#39;Number of instances 2&#39;</code></pre>
<h3 id="inheritance">Inheritance</h3>
<pre><code class="lang-coffeescript">class Vehicle
  fuel: 100
  constructor: (@type, @hero) -&gt;
  use: -&gt;
    @fuel--
    if @fuel &gt; 0
      console.log &quot;#{@hero} is using a #{@type}&quot;
    else
      console.log &quot;Upps!! No fuel in the tank of #{@constructor.name}&quot;

class BatMobile extends Vehicle
  constructor: -&gt; super &quot;car&quot;, &quot;Batman&quot;
batmobile = new BatMobile()
batmobile.use() # &#39;Batman is using a car&#39;

class BatPod extends Vehicle
  fuel: 0
  constructor: -&gt; super &quot;moto&quot;, &quot;Robin&quot;
  refuel: -&gt;
    @fuel = 10
batpod = new BatPod()
batpod.use() # &#39;Upps!! No fuel in the tank of BatPod&#39;
batpod.refuel()
batpod.use() # &#39;Robin is using a moto&#39;</code></pre>
<h3 id="polimorfism">Polimorfism</h3>
<p>Different behaviours for one function</p>
<pre><code class="lang-coffeescript">class Vehicle
  constructor: (@fuel = 10) -&gt;
  burnout: -&gt;
    throw new Error &quot;I&#39;m an abstract method&quot;

class BatMobile extends Vehicle
  constructor: -&gt;
    super fuel = 50
  burnout: -&gt;
    console.log @fuel / 25

class BatPod extends Vehicle
  burnout: -&gt;
    console.log @fuel / 8</code></pre>
<h2 id="modularization">Modularization</h2>
<h3 id="namespaces">Namespaces</h3>
<p>A way to solve it is declaring a global var and puting inside what we need, this way we can work with several works and all of them will have that global object</p>
<pre><code class="lang-coffeescript">(global or window).libjs = {}

#math.coffee
libjs.math =
  sum: (a, b) -&gt; a + b
  rest: (a, b) -&gt; a - b
#const.coffee
libjs.CONST =
  MIN: 10
  MAX: 50
#classes.coffee
class jibjs.Hero</code></pre>
<h3 id="mixins">Mixins</h3>
<pre><code class="lang-coffeescript">extend = (obj, mixin) -&gt;
  obj[name] = method for name, method of mixin obj

include = (class_reference ,mixin) -&gt;
  extend class_reference.prototype, mixin

include Hero ,film: true
(new Hero).film</code></pre>
<script src='http://localhost:35729/livereload.js'></script>

  </body>
</html>
